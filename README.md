# Philosophers

The philosopher problem is a really common exercice handeling multi-threading.
Basically, we consider for example 8 philosophers around a round table eating spaghettis. Actually we don't know if they eat these with bolognese or cream... Wathever :)
There is a fork between each of them, in total 8 forks are on the table. Philosophers need 2 forks to eat : the one on their left and the one on their right. The goal here is to avoid philosophers from dying by feeding them in the smallest gap of time. We have a time constraint for the interval of time in which they should eat to avoid death.

| | |
| -- | --|
| Arguments | number_of_philosophers <br>time_to_die <br>time_to_eat <br>time_to_sleep <br>number_of_times_each_philosopher_must_eat (this one is optional) |
| Output | each change of state of a philosopher with its number and the timestamp in milliseconds : <br> - _timestamp_in_ms X has taken a fork_<br> - _timestamp_in_ms X is eating_ <br> - _timestamp_in_ms X is sleeping_ <br> - _timestamp_in_ms X is thinking_ <br> - _timestamp_in_ms X died_

## Mandatory part

In this project each philosopher is a **thread** which means that they are executing "simultaniously".  In practice, as we can use a big number of philosophers, the execution of each thread will not be simultanious. What will happen is that a small portion of each will be executed one after the other. In real life the user won't notice it because the transitions between the thread's execution will be really fast. Based on the number of cores of your CPU (Central Prossecing Unit), some threads will indeed be executed at the same time but each core will pass hand from one thread to an other.

I chose to seperate even philosophers from odd philosophers by starting to feed even philos to avoid neighbours from both taking a single fork which would have resulted in death. After this start, I then have a **mutex** to protect the state of each fork (available or busy). A mutex allows us to "block" a portion of code which will ensure that only one thread will execute it at a time. You usually use it to avoid **data races** (two threads access the same shared memory space). Since operations are usually not atomic (they are not inseperable : more than a single operation in asm) it could result in errors (during an incrementation for example). If the two forks next to a philo are available, I directly block them (also in a mutex to avoid stealing forks) and then the philo can start eating. In the case of an odd number of philosophers, I have a loop in which I accord a priority to the philosopher that is waiting since a long time and that has a single fork available next to him to ensure that he will eat in the next "eating round".

## Bonus part

The bonus part is a small variant of the original problem which actually changes everything in the program. The forks are no longer numbered between each philos but are in the center of the table. We still have as much forks as philos. While forks are available, a philo can take them to eat spaghettis. Each philo sould now be a **process** and forks are now represented by **semaphores**. A semaphore is defined by a number and two operations : `sem_wait()` and `sem_post()` which respectively decrement and increment this number. If a process or a thread sem_wait but the number is zero then it will be added to the queue and wait until the number is at least one. A binary semaophore is analogic to a mutex but can communicate between different processes. As you could have guessed, our forks are represented by a semaphore with the number of philosophers as a value. I block forks 2 by 2 to avoid each philo from having only one fork. Then the algorithm part is done because the queue ganranties to give forks to philos in the right order (even if the philos are odd). Then I added binary semaphores to avoid data races inside each process. Indeed there is no shared memory between my processes (`pipe()` was forbidden) but each process had 3 threads, the routine of the philo, the death monitor (the program should stop immediately after the death of a philo so if one philo is in the queue while another one dies, I don't have another option than having another thread to alert my philo that someone died and sem_post the forks) and another monitors that stops the execution if philos have all eaten enough (last optionnal argument).
